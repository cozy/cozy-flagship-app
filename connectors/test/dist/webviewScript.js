module.exports = {
  source: "/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_ContentScript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* eslint-disable no-console */\n\n\n\nclass TestContenScript extends _libs_ContentScript__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  async ensureAuthenticated() {\n    return true\n  }\n  async getAccountInformation() {\n    return {\n      email: 'toto@cozycloud.cc',\n    }\n  }\n  async fetch() {\n    this.log('data is fetched')\n    return 'fetch result'\n  }\n}\n\nconst connector = new TestContenScript()\nconnector.init().catch((err) => {\n  console.error(err)\n})\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ContentScript; });\n/* harmony import */ var _bridge_LauncherBridge_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n\n\nclass ContentScript {\n  async init() {\n    this.bridge = new _bridge_LauncherBridge_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({localWindow: window})\n    const exposedMethodsNames = [\n      'ensureAuthenticated',\n      'getAccountInformation',\n      'fetch',\n    ]\n    const exposedMethods = {}\n    // TODO error handling\n    // should catch and call onError on the launcher to let it handle the job update\n    for (const method of exposedMethodsNames) {\n      exposedMethods[method] = this[method].bind(this)\n    }\n    await this.bridge.init({exposedMethods})\n  }\n  log(message) {\n    this.bridge.emit('log', message)\n  }\n  async ensureAuthenticated() {}\n  async getAccountInformation() {}\n  async fetch({context}) {}\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LauncherBridge; });\n/* harmony import */ var post_me__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);\n/* harmony import */ var _ContentScriptMessenger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);\n/* harmony import */ var _libs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n\n\n\n\n/**\n * Bridge to the Launcher object via post-me\n */\nclass LauncherBridge extends _libs__WEBPACK_IMPORTED_MODULE_2__[\"Bridge\"] {\n  constructor({localWindow}) {\n    this.localWindow = localWindow\n  }\n\n  async init({exposedMethods = {}} = {}) {\n    const messenger = new _ContentScriptMessenger_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n      localWindow: this.localWindow,\n    })\n    this.connection = await Object(post_me__WEBPACK_IMPORTED_MODULE_0__[\"ChildHandshake\"])(messenger, exposedMethods)\n    this.localHandle = this.connection.localHandle()\n    this.remoteHandle = this.connection.remoteHandle()\n  }\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BareMessenger\", function() { return BareMessenger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChildHandshake\", function() { return ChildHandshake; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConcreteEmitter\", function() { return ConcreteEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DebugMessenger\", function() { return DebugMessenger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParentHandshake\", function() { return ParentHandshake; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PortMessenger\", function() { return PortMessenger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WindowMessenger\", function() { return WindowMessenger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WorkerMessenger\", function() { return WorkerMessenger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debug\", function() { return debug; });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MARKER = '@post-me';\n\nfunction createUniqueIdFn() {\n  var __id = 0;\n  return function () {\n    var id = __id;\n    __id += 1;\n    return id;\n  };\n}\n/**\n * A concrete implementation of the {@link Emitter} interface\n *\n * @public\n */\n\n\nvar ConcreteEmitter = /*#__PURE__*/function () {\n  function ConcreteEmitter() {\n    _classCallCheck(this, ConcreteEmitter);\n\n    this._listeners = {};\n  }\n  /** {@inheritDoc Emitter.addEventListener} */\n\n\n  _createClass(ConcreteEmitter, [{\n    key: \"addEventListener\",\n    value: function addEventListener(eventName, listener) {\n      var listeners = this._listeners[eventName];\n\n      if (!listeners) {\n        listeners = new Set();\n        this._listeners[eventName] = listeners;\n      }\n\n      listeners.add(listener);\n    }\n    /** {@inheritDoc Emitter.removeEventListener} */\n\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(eventName, listener) {\n      var listeners = this._listeners[eventName];\n\n      if (!listeners) {\n        return;\n      }\n\n      listeners[\"delete\"](listener);\n    }\n    /** {@inheritDoc Emitter.once} */\n\n  }, {\n    key: \"once\",\n    value: function once(eventName) {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        var listener = function listener(data) {\n          _this.removeEventListener(eventName, listener);\n\n          resolve(data);\n        };\n\n        _this.addEventListener(eventName, listener);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"emit\",\n    value: function emit(eventName, data) {\n      var listeners = this._listeners[eventName];\n\n      if (!listeners) {\n        return;\n      }\n\n      listeners.forEach(function (listener) {\n        listener(data);\n      });\n    }\n    /** @internal */\n\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      Object.values(this._listeners).forEach(function (listeners) {\n        if (listeners) {\n          listeners.clear();\n        }\n      });\n    }\n  }]);\n\n  return ConcreteEmitter;\n}();\n\nvar MessageType;\n\n(function (MessageType) {\n  MessageType[\"HandshakeRequest\"] = \"handshake-request\";\n  MessageType[\"HandshakeResponse\"] = \"handshake-response\";\n  MessageType[\"Call\"] = \"call\";\n  MessageType[\"Response\"] = \"response\";\n  MessageType[\"Error\"] = \"error\";\n  MessageType[\"Event\"] = \"event\";\n  MessageType[\"Callback\"] = \"callback\";\n})(MessageType || (MessageType = {})); // Message Creators\n\n\nfunction createHandshakeRequestMessage(sessionId) {\n  return {\n    type: MARKER,\n    action: MessageType.HandshakeRequest,\n    sessionId: sessionId\n  };\n}\n\nfunction createHandshakeResponseMessage(sessionId) {\n  return {\n    type: MARKER,\n    action: MessageType.HandshakeResponse,\n    sessionId: sessionId\n  };\n}\n\nfunction createCallMessage(sessionId, requestId, methodName, args) {\n  return {\n    type: MARKER,\n    action: MessageType.Call,\n    sessionId: sessionId,\n    requestId: requestId,\n    methodName: methodName,\n    args: args\n  };\n}\n\nfunction createResponsMessage(sessionId, requestId, result, error) {\n  var message = {\n    type: MARKER,\n    action: MessageType.Response,\n    sessionId: sessionId,\n    requestId: requestId\n  };\n\n  if (result !== undefined) {\n    message.result = result;\n  }\n\n  if (error !== undefined) {\n    message.error = error;\n  }\n\n  return message;\n}\n\nfunction createCallbackMessage(sessionId, requestId, callbackId, args) {\n  return {\n    type: MARKER,\n    action: MessageType.Callback,\n    sessionId: sessionId,\n    requestId: requestId,\n    callbackId: callbackId,\n    args: args\n  };\n}\n\nfunction createEventMessage(sessionId, eventName, payload) {\n  return {\n    type: MARKER,\n    action: MessageType.Event,\n    sessionId: sessionId,\n    eventName: eventName,\n    payload: payload\n  };\n} // Type Guards\n\n\nfunction isMessage(m) {\n  return m && m.type === MARKER;\n}\n\nfunction isHandshakeRequestMessage(m) {\n  return isMessage(m) && m.action === MessageType.HandshakeRequest;\n}\n\nfunction isHandshakeResponseMessage(m) {\n  return isMessage(m) && m.action === MessageType.HandshakeResponse;\n}\n\nfunction isCallMessage(m) {\n  return isMessage(m) && m.action === MessageType.Call;\n}\n\nfunction isResponseMessage(m) {\n  return isMessage(m) && m.action === MessageType.Response;\n}\n\nfunction isCallbackMessage(m) {\n  return isMessage(m) && m.action === MessageType.Callback;\n}\n\nfunction isEventMessage(m) {\n  return isMessage(m) && m.action === MessageType.Event;\n}\n\nfunction makeCallbackEvent(requestId) {\n  return \"callback_\".concat(requestId);\n}\n\nfunction makeResponseEvent(requestId) {\n  return \"response_\".concat(requestId);\n}\n\nvar Dispatcher = /*#__PURE__*/function (_ConcreteEmitter) {\n  _inherits(Dispatcher, _ConcreteEmitter);\n\n  var _super = _createSuper(Dispatcher);\n\n  function Dispatcher(messenger, sessionId) {\n    var _this2;\n\n    _classCallCheck(this, Dispatcher);\n\n    _this2 = _super.call(this);\n    _this2.uniqueId = createUniqueIdFn();\n    _this2.messenger = messenger;\n    _this2.sessionId = sessionId;\n    _this2.removeMessengerListener = _this2.messenger.addMessageListener(_this2.messengerListener.bind(_assertThisInitialized(_this2)));\n    return _this2;\n  }\n\n  _createClass(Dispatcher, [{\n    key: \"messengerListener\",\n    value: function messengerListener(event) {\n      var data = event.data;\n\n      if (!isMessage(data)) {\n        return;\n      }\n\n      if (this.sessionId !== data.sessionId) {\n        return;\n      }\n\n      if (isCallMessage(data)) {\n        this.emit(MessageType.Call, data);\n      } else if (isResponseMessage(data)) {\n        this.emit(makeResponseEvent(data.requestId), data);\n      } else if (isEventMessage(data)) {\n        this.emit(MessageType.Event, data);\n      } else if (isCallbackMessage(data)) {\n        this.emit(makeCallbackEvent(data.requestId), data);\n      }\n    }\n  }, {\n    key: \"callOnRemote\",\n    value: function callOnRemote(methodName, args, transfer) {\n      var requestId = this.uniqueId();\n      var callbackEvent = makeCallbackEvent(requestId);\n      var responseEvent = makeResponseEvent(requestId);\n      var message = createCallMessage(this.sessionId, requestId, methodName, args);\n      this.messenger.postMessage(message, transfer);\n      return {\n        callbackEvent: callbackEvent,\n        responseEvent: responseEvent\n      };\n    }\n  }, {\n    key: \"respondToRemote\",\n    value: function respondToRemote(requestId, value, error, transfer) {\n      if (error instanceof Error) {\n        error = {\n          name: error.name,\n          message: error.message\n        };\n      }\n\n      var message = createResponsMessage(this.sessionId, requestId, value, error);\n      this.messenger.postMessage(message, transfer);\n    }\n  }, {\n    key: \"callbackToRemote\",\n    value: function callbackToRemote(requestId, callbackId, args) {\n      var message = createCallbackMessage(this.sessionId, requestId, callbackId, args);\n      this.messenger.postMessage(message);\n    }\n  }, {\n    key: \"emitToRemote\",\n    value: function emitToRemote(eventName, payload, transfer) {\n      var message = createEventMessage(this.sessionId, eventName, payload);\n      this.messenger.postMessage(message, transfer);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.removeMessengerListener();\n      this.removeAllListeners();\n    }\n  }]);\n\n  return Dispatcher;\n}(ConcreteEmitter);\n\nvar ParentHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter2) {\n  _inherits(ParentHandshakeDispatcher, _ConcreteEmitter2);\n\n  var _super2 = _createSuper(ParentHandshakeDispatcher);\n\n  function ParentHandshakeDispatcher(messenger, sessionId) {\n    var _this3;\n\n    _classCallCheck(this, ParentHandshakeDispatcher);\n\n    _this3 = _super2.call(this);\n    _this3.messenger = messenger;\n    _this3.sessionId = sessionId;\n    _this3.removeMessengerListener = _this3.messenger.addMessageListener(_this3.messengerListener.bind(_assertThisInitialized(_this3)));\n    return _this3;\n  }\n\n  _createClass(ParentHandshakeDispatcher, [{\n    key: \"messengerListener\",\n    value: function messengerListener(event) {\n      var data = event.data;\n\n      if (!isMessage(data)) {\n        return;\n      }\n\n      if (this.sessionId !== data.sessionId) {\n        return;\n      }\n\n      if (isHandshakeResponseMessage(data)) {\n        this.emit(data.sessionId, data);\n      }\n    }\n  }, {\n    key: \"initiateHandshake\",\n    value: function initiateHandshake() {\n      var message = createHandshakeRequestMessage(this.sessionId);\n      this.messenger.postMessage(message);\n      return this.sessionId;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.removeMessengerListener();\n      this.removeAllListeners();\n    }\n  }]);\n\n  return ParentHandshakeDispatcher;\n}(ConcreteEmitter);\n\nvar ChildHandshakeDispatcher = /*#__PURE__*/function (_ConcreteEmitter3) {\n  _inherits(ChildHandshakeDispatcher, _ConcreteEmitter3);\n\n  var _super3 = _createSuper(ChildHandshakeDispatcher);\n\n  function ChildHandshakeDispatcher(messenger) {\n    var _this4;\n\n    _classCallCheck(this, ChildHandshakeDispatcher);\n\n    _this4 = _super3.call(this);\n    _this4.messenger = messenger;\n    _this4.removeMessengerListener = _this4.messenger.addMessageListener(_this4.messengerListener.bind(_assertThisInitialized(_this4)));\n    return _this4;\n  }\n\n  _createClass(ChildHandshakeDispatcher, [{\n    key: \"messengerListener\",\n    value: function messengerListener(event) {\n      var data = event.data;\n\n      if (isHandshakeRequestMessage(data)) {\n        this.emit(MessageType.HandshakeRequest, data);\n      }\n    }\n  }, {\n    key: \"acceptHandshake\",\n    value: function acceptHandshake(sessionId) {\n      var message = createHandshakeResponseMessage(sessionId);\n      this.messenger.postMessage(message);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.removeMessengerListener();\n      this.removeAllListeners();\n    }\n  }]);\n\n  return ChildHandshakeDispatcher;\n}(ConcreteEmitter);\n\nvar ProxyType;\n\n(function (ProxyType) {\n  ProxyType[\"Callback\"] = \"callback\";\n})(ProxyType || (ProxyType = {}));\n\nfunction createCallbackProxy(callbackId) {\n  return {\n    type: MARKER,\n    proxy: ProxyType.Callback,\n    callbackId: callbackId\n  };\n}\n\nfunction isCallbackProxy(p) {\n  return p && p.type === MARKER && p.proxy === ProxyType.Callback;\n}\n\nvar ConcreteRemoteHandle = /*#__PURE__*/function (_ConcreteEmitter4) {\n  _inherits(ConcreteRemoteHandle, _ConcreteEmitter4);\n\n  var _super4 = _createSuper(ConcreteRemoteHandle);\n\n  function ConcreteRemoteHandle(dispatcher) {\n    var _this5;\n\n    _classCallCheck(this, ConcreteRemoteHandle);\n\n    _this5 = _super4.call(this);\n    _this5._dispatcher = dispatcher;\n    _this5._callTransfer = {};\n\n    _this5._dispatcher.addEventListener(MessageType.Event, _this5._handleEvent.bind(_assertThisInitialized(_this5)));\n\n    return _this5;\n  }\n\n  _createClass(ConcreteRemoteHandle, [{\n    key: \"close\",\n    value: function close() {\n      this.removeAllListeners();\n    }\n  }, {\n    key: \"setCallTransfer\",\n    value: function setCallTransfer(methodName, transfer) {\n      this._callTransfer[methodName] = transfer;\n    }\n  }, {\n    key: \"call\",\n    value: function call(methodName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return this.customCall(methodName, args);\n    }\n  }, {\n    key: \"customCall\",\n    value: function customCall(methodName, args) {\n      var _this6 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return new Promise(function (resolve, reject) {\n        var sanitizedArgs = [];\n        var callbacks = [];\n        var callbackId = 0;\n        args.forEach(function (arg) {\n          if (typeof arg === 'function') {\n            callbacks.push(arg);\n            sanitizedArgs.push(createCallbackProxy(callbackId));\n            callbackId += 1;\n          } else {\n            sanitizedArgs.push(arg);\n          }\n        });\n        var hasCallbacks = callbacks.length > 0;\n        var callbackListener = undefined;\n\n        if (hasCallbacks) {\n          callbackListener = function callbackListener(data) {\n            var callbackId = data.callbackId,\n                args = data.args;\n            callbacks[callbackId].apply(callbacks, _toConsumableArray(args));\n          };\n        }\n\n        var transfer = options.transfer;\n\n        if (transfer === undefined && _this6._callTransfer[methodName]) {\n          var _this6$_callTransfer;\n\n          transfer = (_this6$_callTransfer = _this6._callTransfer)[methodName].apply(_this6$_callTransfer, sanitizedArgs);\n        }\n\n        var _this6$_dispatcher$ca = _this6._dispatcher.callOnRemote(methodName, sanitizedArgs, transfer),\n            callbackEvent = _this6$_dispatcher$ca.callbackEvent,\n            responseEvent = _this6$_dispatcher$ca.responseEvent;\n\n        if (hasCallbacks) {\n          _this6._dispatcher.addEventListener(callbackEvent, callbackListener);\n        }\n\n        _this6._dispatcher.once(responseEvent).then(function (response) {\n          if (callbackListener) {\n            _this6._dispatcher.removeEventListener(callbackEvent, callbackListener);\n          }\n\n          var result = response.result,\n              error = response.error;\n\n          if (error !== undefined) {\n            reject(error);\n          } else {\n            resolve(result);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function _handleEvent(data) {\n      var eventName = data.eventName,\n          payload = data.payload;\n      this.emit(eventName, payload);\n    }\n  }]);\n\n  return ConcreteRemoteHandle;\n}(ConcreteEmitter);\n\nvar ConcreteLocalHandle = /*#__PURE__*/function () {\n  function ConcreteLocalHandle(dispatcher, localMethods) {\n    _classCallCheck(this, ConcreteLocalHandle);\n\n    this._dispatcher = dispatcher;\n    this._methods = localMethods;\n    this._returnTransfer = {};\n    this._emitTransfer = {};\n\n    this._dispatcher.addEventListener(MessageType.Call, this._handleCall.bind(this));\n  }\n\n  _createClass(ConcreteLocalHandle, [{\n    key: \"emit\",\n    value: function emit(eventName, payload) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var transfer = options.transfer;\n\n      if (transfer === undefined && this._emitTransfer[eventName]) {\n        transfer = this._emitTransfer[eventName](payload);\n      }\n\n      this._dispatcher.emitToRemote(eventName, payload, transfer);\n    }\n  }, {\n    key: \"setMethods\",\n    value: function setMethods(methods) {\n      this._methods = methods;\n    }\n  }, {\n    key: \"setMethod\",\n    value: function setMethod(methodName, method) {\n      this._methods[methodName] = method;\n    }\n  }, {\n    key: \"setReturnTransfer\",\n    value: function setReturnTransfer(methodName, transfer) {\n      this._returnTransfer[methodName] = transfer;\n    }\n  }, {\n    key: \"setEmitTransfer\",\n    value: function setEmitTransfer(eventName, transfer) {\n      this._emitTransfer[eventName] = transfer;\n    }\n  }, {\n    key: \"_handleCall\",\n    value: function _handleCall(data) {\n      var _this7 = this;\n\n      var requestId = data.requestId,\n          methodName = data.methodName,\n          args = data.args;\n      var callMethod = new Promise(function (resolve, reject) {\n        var _this7$_methods;\n\n        var method = _this7._methods[methodName];\n\n        if (typeof method !== 'function') {\n          reject(new Error(\"The method \\\"\".concat(methodName, \"\\\" has not been implemented.\")));\n          return;\n        }\n\n        var desanitizedArgs = args.map(function (arg) {\n          if (isCallbackProxy(arg)) {\n            var callbackId = arg.callbackId;\n            return function () {\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n\n              _this7._dispatcher.callbackToRemote(requestId, callbackId, args);\n            };\n          } else {\n            return arg;\n          }\n        });\n        Promise.resolve((_this7$_methods = _this7._methods)[methodName].apply(_this7$_methods, _toConsumableArray(desanitizedArgs))).then(resolve)[\"catch\"](reject);\n      });\n      callMethod.then(function (result) {\n        var transfer;\n\n        if (_this7._returnTransfer[methodName]) {\n          transfer = _this7._returnTransfer[methodName](result);\n        }\n\n        _this7._dispatcher.respondToRemote(requestId, result, undefined, transfer);\n      })[\"catch\"](function (error) {\n        _this7._dispatcher.respondToRemote(requestId, undefined, error);\n      });\n    }\n  }]);\n\n  return ConcreteLocalHandle;\n}();\n\nvar ConcreteConnection = /*#__PURE__*/function () {\n  function ConcreteConnection(dispatcher, localMethods) {\n    _classCallCheck(this, ConcreteConnection);\n\n    this._dispatcher = dispatcher;\n    this._localHandle = new ConcreteLocalHandle(dispatcher, localMethods);\n    this._remoteHandle = new ConcreteRemoteHandle(dispatcher);\n  }\n\n  _createClass(ConcreteConnection, [{\n    key: \"close\",\n    value: function close() {\n      this._dispatcher.close();\n\n      this.remoteHandle().close();\n    }\n  }, {\n    key: \"localHandle\",\n    value: function localHandle() {\n      return this._localHandle;\n    }\n  }, {\n    key: \"remoteHandle\",\n    value: function remoteHandle() {\n      return this._remoteHandle;\n    }\n  }]);\n\n  return ConcreteConnection;\n}();\n\nvar uniqueSessionId = createUniqueIdFn();\n\nvar runUntil = function runUntil(worker, condition, unfulfilled, maxAttempts, attemptInterval) {\n  var attempt = 0;\n\n  var fn = function fn() {\n    if (!condition() && (attempt < maxAttempts || maxAttempts < 1)) {\n      worker();\n      attempt += 1;\n      setTimeout(fn, attemptInterval);\n    } else if (!condition() && attempt >= maxAttempts && maxAttempts >= 1) {\n      unfulfilled();\n    }\n  };\n\n  fn();\n};\n/**\n * Initiate the handshake from the Parent side\n *\n * @param messenger - The Messenger used to send and receive messages from the other end\n * @param localMethods - The methods that will be exposed to the other end\n * @param maxAttempts - The maximum number of handshake attempts\n * @param attemptsInterval - The interval between handshake attempts\n * @returns A Promise to an active {@link Connection} to the other end\n *\n * @public\n */\n\n\nfunction ParentHandshake(messenger) {\n  var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  var attemptsInterval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n  var thisSessionId = uniqueSessionId();\n  var connected = false;\n  return new Promise(function (resolve, reject) {\n    var handshakeDispatcher = new ParentHandshakeDispatcher(messenger, thisSessionId);\n    handshakeDispatcher.once(thisSessionId).then(function (response) {\n      connected = true;\n      handshakeDispatcher.close();\n      var sessionId = response.sessionId;\n      var dispatcher = new Dispatcher(messenger, sessionId);\n      var connection = new ConcreteConnection(dispatcher, localMethods);\n      resolve(connection);\n    });\n    runUntil(function () {\n      return handshakeDispatcher.initiateHandshake();\n    }, function () {\n      return connected;\n    }, function () {\n      return reject(new Error(\"Handshake failed, reached maximum number of attempts\"));\n    }, maxAttempts, attemptsInterval);\n  });\n}\n/**\n * Initiate the handshake from the Child side\n *\n * @param messenger - The Messenger used to send and receive messages from the other end\n * @param localMethods - The methods that will be exposed to the other end\n * @returns A Promise to an active {@link Connection} to the other end\n *\n * @public\n */\n\n\nfunction ChildHandshake(messenger) {\n  var localMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    var handshakeDispatcher = new ChildHandshakeDispatcher(messenger);\n    handshakeDispatcher.once(MessageType.HandshakeRequest).then(function (response) {\n      var sessionId = response.sessionId;\n      handshakeDispatcher.acceptHandshake(sessionId);\n      handshakeDispatcher.close();\n      var dispatcher = new Dispatcher(messenger, sessionId);\n      var connection = new ConcreteConnection(dispatcher, localMethods);\n      resolve(connection);\n    });\n  });\n}\n\nvar acceptableMessageEvent = function acceptableMessageEvent(event, remoteWindow, acceptedOrigin) {\n  var source = event.source,\n      origin = event.origin;\n\n  if (source !== remoteWindow) {\n    return false;\n  }\n\n  if (origin !== acceptedOrigin && acceptedOrigin !== '*') {\n    return false;\n  }\n\n  return true;\n};\n/**\n * A concrete implementation of {@link Messenger} used to communicate with another Window.\n *\n * @public\n *\n */\n\n\nvar WindowMessenger = function WindowMessenger(_ref) {\n  var localWindow = _ref.localWindow,\n      remoteWindow = _ref.remoteWindow,\n      remoteOrigin = _ref.remoteOrigin;\n\n  _classCallCheck(this, WindowMessenger);\n\n  localWindow = localWindow || window;\n\n  this.postMessage = function (message, transfer) {\n    remoteWindow.postMessage(message, remoteOrigin, transfer);\n  };\n\n  this.addMessageListener = function (listener) {\n    var outerListener = function outerListener(event) {\n      if (acceptableMessageEvent(event, remoteWindow, remoteOrigin)) {\n        listener(event);\n      }\n    };\n\n    localWindow.addEventListener('message', outerListener);\n\n    var removeListener = function removeListener() {\n      localWindow.removeEventListener('message', outerListener);\n    };\n\n    return removeListener;\n  };\n};\n/** @public */\n\n\nvar BareMessenger = function BareMessenger(postable) {\n  _classCallCheck(this, BareMessenger);\n\n  this.postMessage = function (message) {\n    var transfer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    postable.postMessage(message, transfer);\n  };\n\n  this.addMessageListener = function (listener) {\n    var outerListener = function outerListener(event) {\n      listener(event);\n    };\n\n    postable.addEventListener('message', outerListener);\n\n    var removeListener = function removeListener() {\n      postable.removeEventListener('message', outerListener);\n    };\n\n    return removeListener;\n  };\n};\n/**\n * A concrete implementation of {@link Messenger} used to communicate with a Worker.\n *\n * Takes a {@link Postable} representing the `Worker` (when calling from\n * the parent context) or the `self` `DedicatedWorkerGlobalScope` object\n * (when calling from the child context).\n *\n * @public\n *\n */\n\n\nvar WorkerMessenger = /*#__PURE__*/function (_BareMessenger) {\n  _inherits(WorkerMessenger, _BareMessenger);\n\n  var _super5 = _createSuper(WorkerMessenger);\n\n  function WorkerMessenger(_ref2) {\n    var worker = _ref2.worker;\n\n    _classCallCheck(this, WorkerMessenger);\n\n    return _super5.call(this, worker);\n  }\n\n  return WorkerMessenger;\n}(BareMessenger);\n/**\n * A concrete implementation of {@link Messenger} used to communicate with a MessagePort.\n *\n * @public\n *\n */\n\n\nvar PortMessenger = /*#__PURE__*/function (_BareMessenger2) {\n  _inherits(PortMessenger, _BareMessenger2);\n\n  var _super6 = _createSuper(PortMessenger);\n\n  function PortMessenger(_ref3) {\n    var port = _ref3.port;\n\n    _classCallCheck(this, PortMessenger);\n\n    port.start();\n    return _super6.call(this, port);\n  }\n\n  return PortMessenger;\n}(BareMessenger);\n/**\n * Create a logger function with a specific namespace\n *\n * @param namespace - The namespace will be prepended to all the arguments passed to the logger function\n * @param log - The underlying logger (`console.log` by default)\n *\n * @public\n *\n */\n\n\nfunction debug(namespace, log) {\n  log = log || console.debug || console.log || function () {};\n\n  return function () {\n    for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      data[_key3] = arguments[_key3];\n    }\n\n    log.apply(void 0, [namespace].concat(data));\n  };\n}\n/**\n * Decorate a {@link Messenger} so that it will log any message exchanged\n * @param messenger - The Messenger that will be decorated\n * @param log - The logger function that will receive each message\n * @returns A decorated Messenger\n *\n * @public\n *\n */\n\n\nfunction DebugMessenger(messenger, log) {\n  log = log || debug('post-me');\n\n  var debugListener = function debugListener(event) {\n    var data = event.data;\n    log('⬅️ received message', data);\n  };\n\n  messenger.addMessageListener(debugListener);\n  return {\n    postMessage: function postMessage(message, transfer) {\n      log('➡️ sending message', message);\n      messenger.postMessage(message, transfer);\n    },\n    addMessageListener: function addMessageListener(listener) {\n      return messenger.addMessageListener(listener);\n    }\n  };\n}\n\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ContentScriptMessenger; });\n/* harmony import */ var _libs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n\n\n/**\n * post-me messenger implementation for a content script\n */\nclass ContentScriptMessenger extends _libs__WEBPACK_IMPORTED_MODULE_0__[\"MessengerInterface\"] {\n  constructor({localWindow}) {\n    this.localWindow = localWindow\n  }\n  postMessage(message) {\n    this.localWindow.ReactNativeWebView.postMessage(JSON.stringify(message))\n  }\n  addMessageListener(listener) {\n    const outerListener = (event) => {\n      listener(event)\n    }\n\n    this.localWindow.addEventListener('message', outerListener)\n\n    const removeListener = () => {\n      this.localWindow.removeEventListener('message', outerListener)\n    }\n\n    return removeListener\n  }\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_libs_bridgeHelpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Bridge\", function() { return _src_libs_bridgeHelpers__WEBPACK_IMPORTED_MODULE_0__[\"Bridge\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MessengerInterface\", function() { return _src_libs_bridgeHelpers__WEBPACK_IMPORTED_MODULE_0__[\"MessengerInterface\"]; });\n\n/**\n * Short cut to launcher's bridgeHelpers interfaces and classes\n * Will probably become a npm package in the future\n */\n\n\n\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bridge\", function() { return Bridge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessengerInterface\", function() { return MessengerInterface; });\n/**\n * @typedef PostMeConnection\n * @property {function} localHandle  : get handle to the local end of the connection\n * @property {function} remoteHandle : get handle to the remote end of the connection\n * @property {function} close        : stop listening to incoming message from the other side\n */\n\n/**\n * All bridges are supposed to implement this interface\n */\nclass Bridge {\n  /**\n   * Initialize the communication between the parent and the child via post-me protocol\n   * https://github.com/alesgenova/post-me\n   *\n   * @param  {Object} options.exposedMethods  : The list of methods of the launcher and their implementation, which will be exposed via the post-me interface\n   * @return {PostMeConnection} : the resulting post-me connection\n   */\n  async init({exposedMethods}) {}\n\n  /**\n   * Shortcut to remoteHandle.call method\n   *\n   * @param  {string} method : The remote method name\n   * @param  {array} args    : Any number of parameters which will be given to the remote method.\n   * It is also possible to pass callback functions (which must support serialization). post-me\n   * will wait the the remote method end before resolving the promise\n   *\n   *\n   * @return {any} remote method return value\n   */\n  async call(method, ...args) {\n    return this.connection.remoteHandle.call(method, ...args)\n  }\n\n  /**\n   * Shortcut to localHandle.emit method. Will emit an event which could be listened by the remote\n   * object\n   *\n   * @param  {string} eventName\n   * @param  {array} args : Any number of parameters.\n   */\n  emit(eventName, ...args) {\n    this.connection.localHandle.emit(eventName, ...args)\n  }\n\n  /**\n   * Shortcut to remoteHandle.addEventListener method. Will listen to the given event on the remote\n   * object and call the listener function\n   *\n   * @param  {string} remoteEventName\n   * @param  {function} listener\n   */\n  addEventListener(remoteEventName, listener) {\n    this.connection.remoteHandle.addEventListener(remoteEventName, listener)\n  }\n}\n\n/**\n * All messengers are supposed to implement this interface\n *\n * @interface\n */\nclass MessengerInterface {\n  /**\n   * Send a message to the other context\n   *\n   * @param {string} message : The payload of the message\n   */\n  postMessage(message) {}\n\n  /**\n   * Add a listener to messages received by the other context\n   *\n   * @param {function} listener : A listener that will receive the MessageEvent\n   * @return {function} A function that can be invoked to remove the listener\n   */\n  addMessageListener(listener) {}\n}\n\n\n/***/ })\n/******/ ]);",
  manifest: {
  "version": "1.0.0",
  "name": "Connecteur de test",
  "type": "konnector",
  "language": "node",
  "icon": "icon.svg",
  "slug": "test",
  "source": "git@github.com:konnectors/cozy-konnector-sncf.git",
  "editor": "Cozy",
  "vendor_link": "https://www.oui.sncf/espaceclient/accueil",
  "categories": [
    "transport"
  ],
  "fields": { }
}
}